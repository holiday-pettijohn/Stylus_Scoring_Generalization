# Library Functions

## compare_genes.py

Gets heuristic and exhaustive scores for any given algorithm. Contains a specific function to obtain exhaustive scores

`matchError(heuristic_scores, standard_scores)`: retrieves the (log) ratio of heuristic and canonical scores

Input:

heuristic_scores [Array (float)]: list of scores obtained from a heuristic algorithm

standard_scores [Array (float)]: list of scores obtained from a canonical score source, such as exhaustive search or the original gene file

Output:

scores [Array (float)]: list of log ratios between the standard and heuristic score. Higher values indicate more error.

`getScores(ref_char, data_dir)`: Calculates scores for a set of gene characters against a given reference with a heuristic algorithm. Files from the directory specified with gene data are read in a deterministic order (same files = same order)

Input:

algorithm (function): : A function with the below call signature. Takes stroke geometry and archetype geometry and scores the stroke against the archetype

- `algorithm(stroke_geometry, reference_geometry, stroke_fractional_distance, reference_fractional_distance)`

- stroke_geometry [Array[Array] (float)]: List of the strokes from the gene instance

- reference_geometry [Array[Array] (float)]: List of the strokes from the archetype

- stroke_fractional_distance [Array (float)]: List of fractional distances (a.k.a. progress percentages) for each stroke in the gene instance

- reference_fractional_distance [Array (float)]: List of fractional distances (a.k.a. progress percentages) for each stroke in the reference

ref_char [string]: UTF-8 name of the archetype in question

data_dir [string]: Directory with the gene files for testing

Output:

heuristic_scores [Array (float)]: The scores returned from the given algorithm for each of the genes in the directory

heuristic_alignments [Array[Array] (int)]: Alignments which the algorithm returned
marks [Array (bool)]: Whether or not each respective score has a mark, which is an additional stroke which has no counterpart in the archetype

`exhaustiveScores(ref_char, data_dir, timed = False, save = False, file_prefix = "")`: Calculates the Stylus score for the best matching between a given archetype and the gene files in a given directory using exhaustive search. This can take a while, especially for high stroke count archetypes.

Input:

ref_char [string]: UTF-8 name of the archetype in question

data_dir [string]: Directory with the gene files for testing

timed [bool]: Whether to print the time taken to generate exhaustive matchings

save [bool]: Whether to save the results of exhaustive generation to a fixed directory

file_prefix [string] = "": File prefix which will be prepended to generated files if save is True

Output:

exhaustive_scores [Array (float)]: List of Stylus scores for the best matchings between the given archetype and file. Files are iterated in a constant order which can be obtained by running `sorted(files)` on the list of files in question.

## exhaustive.py

Functions for dealing with exhaustive comparisons between Stylus genomes

`computeExhaustive(ref_char, f_read, data_dir, exhaust_dir = "Exhaustive", prog_interval = 100, save = True, xml_dir = "GenXml/Exhaustive", save_file = "")`

Obtains the best Stylus score for a set of genes against one archetype using exhaustive search to find the best alignment

Input:

ref_char [string]: UTF-8 name of the archetype in question

f_read [Array (string)]: List of files within data_dir to search for optimal alignments

data_dir [string]: Directory with the gene files for testing

exhaust_dir [string]: Directory to save exhaustive data to, if data is to be saved and save_file is not specified

prog_interval [int]: Number of genes after which to print a progress update

save [bool]: Whether to save the results of the search to a file

xml_dir [string]: Directory to place xml files generated by exhaustive search

save_file [string]: File to write exhaustive scores to, if scores are to be saved

Output:

exhaustive_scores [Generator[Array, Array] (float, int), ]: Generator for the series of optimal scores for the genes against the given archetype

`computeExhastiveAlign(ref_char, f_read, data_dir, exhaust_dir = "Exhaustive", prog_interval = 100, save = True, xml_dir = "GenXml/Exhaustive", save_file = "")`

Obtains the alignment which obtains the best Stylus score for a set of genes against one archetype using exhaustive search

Input: Identical to the above (computeExhaustive)

Output:

exhaustive_scores [Generator[Array, Array] (float, int), ]: Generator for the series of optimal scores for the genes against the given archetype, paired with the alignments associated with said scores

`readExhaustive`

Reads previously calculated and saved exhaustive score/alignment data

Input:

ref_char [string]: UTF-8 name of the archetype in question

f_name [string]: Name of the gene file associated with the data to be read

exhaust_dir [string]: Directory to read exhaustive data from, if save_file is not specified

save_file [string]: File to read exhaustive scores from. If not specified, this will be inferred from the above arguments

Output:

data_read [Array (float)]: List of scores read from the indicated files

`exhaustScore`

Obtains the best Stylus score for one gene against one archetype using exhaustive search to find the best alignment

Input:

ref_char [string]: UTF-8 name of the archetype in question

f_name [string]: Name of the gene file on which to preform exhaustive search

data_dir [string]: Directory with the gene file for testing

exhaust_dir [string]: Directory to save exhaustive data to, if data is to be saved and save_file is not specified

save [bool]: Whether to save the results of the search to a file

file_prefix [string] = "": File prefix which will be prepended to generated files if save is True

Output:

exhaust_score [float]: Maximum score obtained for the gene against the given archetype using exhaustive search

exhaustive_scores [Generator[Array, Array] (float, int), ]: Generator for the series of optimal scores for the genes against the given archetype

`exhaustScoreAlignment`

Obtains the alignment which obtains the best Stylus score for one gene against one archetype using exhaustive search

Input: Identical to the above (exhaustScore), without file_prefix

Output:

exhaust_align [Array (int)]: Alignment with which to obtain the optimal score for the given gene against the given archetype

## score_strokes.py

Contains current implementations of heuristic matching algorithms of the form which may be tested against exhaustive results given the existing framework

`alignStrokes(strokes, ref, p_strokes, p_ref)`

Use a greedy search alongside an matrix indicating the error between all gene/archetype stroke pairings as a heuristic to find a good alignment between the gene and archetype strokes

The main content of this function is the search method being used (greedy search). The calculations for the error matrix are done independently and invoked by this function, and can thus be independently modified and/or replaced without modifying the greedy search methodology (or visa versa - the error calculations can remain identical while changing the search methodology).

Input:

TODO: Need to check the exact data structure for all stroke lists to verify this

strokes [Array[Array] (float, float)]: list of points in the gene strokes

ref [Array[Array] (float, float)]: list of points in the reference strokes

p_strokes [Array (float)]: percentages of progress for each point in the gene strokes

p_ref [Array (float)]: percentages of progress for each point in the reference strokes

Output:

stroke_map [Array (int)]: a mapping for the strokes from the gene to the archetype character

`strokeErrorMatrix(strokes, ref, p_strokes, p_ref, error_function = maxDeviation)`

Calculates a matrix containing the error measure between each possible pairing of gene and archetype strokes. This is meant to be used within implementations of alignment algorithms.

Input:

strokes [Array[Array] (float, float)]: list of points in the gene strokes

ref [Array[Array] (float, float)]: list of points in the reference strokes

p_strokes [Array (float)]: percentages of progress for each point in the gene strokes

p_ref [Array (float)]: percentages of progress for each point in the reference strokes

error_function (function): A function with the below call signature. Calculates an error value given any two strokes

- `error_function(stroke, ref_stroke, p_stroke, p_ref)`

- Calculates the error between two particular strokes

- Input:

- stroke [Array (float, float)]: list of points in the gene stroke

- ref [Array (float, float)]: list of points in the reference stroke

- p_stroke [Array (float)]: percentage of progress for each point in the gene strokes

- p_ref [Array (float)]: percentage of progress for each point in the reference strokes

- Output:

- error (float): The error between the two strokes

Output:

error_matrix [Array[Array] (float)]: matrix containing the matching error between every stroke pair of form (archetype_stroke, gene_stroke)

`strokeError(stroke, ref_stroke, p_stroke, p_ref)`

Calculates the maximum point deviation between two particular strokes. This is one specific implementation of the above error_function.

Input:

stroke [Array (float, float)]: list of points in the gene stroke

ref [Array (float, float)]: list of points in the reference stroke

p_stroke [Array (float)]: percentage of progress for each point in the gene strokes

p_ref [Array (float)]: percentage of progress for each point in the reference strokes

Output:

error (float): The error between the two strokes

`strokeErrorHybrid(stroke, ref_stroke, p_stroke, p_ref, w1=0.5, w2=0.5)`

Calculates the error between two strokes using a weighted combination of maximum point deviation and mean point deviation.

Input:

Same as general `error_function` with two additional arguments:

w1 (float): weight to give to the first technique (max dev)

w2 (float): weight to give to the second technique (mean dev)

Note: w1+w2 should equal 1 for consistency's sake, but the function will not error if this is not the case

Note: the error_function interface does not pass the weight arguments (w1, w2) by default. To change these, you can wrap the function to pass different default arguments. For example:

```
def wrapper(stroke, ref_stroke, p_stroke, p_ref):
    return strokeErrorHybrid(stroke, ref_stroke, p_stroke, p_ref, w1=0.7, w2=0.3)
```

Output:

Same as general `error_function`

`strokeErrorScaled(stroke, ref_stroke, p_stroke, p_ref)`

Calculates the maximum point deviation between two particular strokes after scaling them on top of each other such that their centers of mass align

Input:

Same as general `error_function`

Output:

Same as general `error_function`

`strokeTrace(stroke, stroke_progresses, progress)`

Interpolates a point along a stroke at a given fractional distance along said stroke

Input:

stroke: list of points in the stroke

stroke_progress: list of fractional distances associated with each point in the stroke

progress: percentage of the way to trace the stroke to interpolate the point

Output:

interpolated_point: point along the stroke found at the provided fractional distance

## xml_parse.py

# Notebooks


